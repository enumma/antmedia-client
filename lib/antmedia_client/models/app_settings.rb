=begin
#Ant Media Server REST API Reference

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: 2.5.3

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.31

=end

require 'date'

module AntmediaClient
  class AppSettings
    attr_accessor :remote_allowed_cidr

    attr_accessor :mp4_muxing_enabled

    attr_accessor :web_m_muxing_enabled

    attr_accessor :add_date_time_to_mp4_file_name

    attr_accessor :file_name_format

    attr_accessor :hls_muxing_enabled

    attr_accessor :encoder_settings_string

    attr_accessor :signaling_enabled

    attr_accessor :signaling_address

    attr_accessor :hls_list_size

    attr_accessor :hls_time

    attr_accessor :upload_extensions_to_s3

    attr_accessor :s3_storage_class

    attr_accessor :endpoint_health_check_period_ms

    attr_accessor :endpoint_republish_limit

    attr_accessor :dash_seg_duration

    attr_accessor :dash_fragment_duration

    attr_accessor :target_latency

    attr_accessor :dash_window_size

    attr_accessor :dash_extra_window_size

    attr_accessor :isl_l_dash_enabled

    attr_accessor :isl_lhls_enabled

    attr_accessor :hls_enabled_via_dash

    attr_accessor :use_timeline_dash_muxing

    attr_accessor :web_rtc_enabled

    attr_accessor :use_original_web_rtc_enabled

    attr_accessor :delete_hls_files_on_ended

    attr_accessor :delete_dash_files_on_ended

    attr_accessor :token_hash_secret

    attr_accessor :hash_control_publish_enabled

    attr_accessor :hash_control_play_enabled

    attr_accessor :listener_hook_url

    attr_accessor :accept_only_streams_in_data_store

    attr_accessor :accept_only_rooms_in_data_store

    attr_accessor :publish_token_control_enabled

    attr_accessor :play_token_control_enabled

    attr_accessor :time_token_subscriber_only

    attr_accessor :enable_time_token_for_play

    attr_accessor :enable_time_token_for_publish

    attr_accessor :time_token_period

    attr_accessor :hls_play_list_type

    attr_accessor :vod_folder

    attr_accessor :preview_overwrite

    attr_accessor :stalker_db_server

    attr_accessor :stalker_db_username

    attr_accessor :stalker_db_password

    attr_accessor :object_detection_enabled

    attr_accessor :create_preview_period

    attr_accessor :restart_stream_fetcher_period

    attr_accessor :start_stream_fetcher_automatically

    attr_accessor :stream_fetcher_buffer_time

    attr_accessor :hlsflags

    attr_accessor :my_sql_client_path

    attr_accessor :muxer_finish_script

    attr_accessor :web_rtc_frame_rate

    attr_accessor :web_rtc_port_range_min

    attr_accessor :web_rtc_port_range_max

    attr_accessor :stun_server_uri

    attr_accessor :turn_server_username

    attr_accessor :turn_server_credential

    attr_accessor :web_rtc_tcp_candidates_enabled

    attr_accessor :web_rtc_sdp_semantics

    attr_accessor :port_allocator_flags

    attr_accessor :collect_social_media_activity

    attr_accessor :encoder_name

    attr_accessor :encoder_preset

    attr_accessor :encoder_profile

    attr_accessor :encoder_level

    attr_accessor :encoder_rc

    attr_accessor :encoder_specific

    attr_accessor :encoder_thread_count

    attr_accessor :encoder_thread_type

    attr_accessor :vp8_encoder_speed

    attr_accessor :vp8_encoder_deadline

    attr_accessor :vp8_encoder_thread_count

    attr_accessor :preview_height

    attr_accessor :generate_preview

    attr_accessor :write_stats_to_datastore

    attr_accessor :encoder_selection_preference

    attr_accessor :allowed_publisher_cidr

    attr_accessor :excessive_bandwidth_value

    attr_accessor :excessive_bandwidth_call_threshold

    attr_accessor :excessive_bandwith_try_count_before_switchback

    attr_accessor :excessive_bandwidth_algorithm_enabled

    attr_accessor :packet_loss_diff_threshold_for_switchback

    attr_accessor :rtt_measurement_diff_threshold_for_switchback

    attr_accessor :replace_candidate_addr_with_server_addr

    attr_accessor :app_name

    attr_accessor :encoding_timeout

    attr_accessor :web_rtc_client_start_timeout_ms

    attr_accessor :default_decoders_enabled

    attr_accessor :update_time

    attr_accessor :http_forwarding_extension

    attr_accessor :http_forwarding_base_url

    attr_accessor :max_analyze_duration_ms

    attr_accessor :disable_ipv6_candidates

    attr_accessor :rtsp_pull_transport_type

    attr_accessor :rtsp_timeout_duration_ms

    attr_accessor :max_resolution_accept

    attr_accessor :h264_enabled

    attr_accessor :vp8_enabled

    attr_accessor :h265_enabled

    attr_accessor :data_channel_enabled

    attr_accessor :data_channel_player_distribution

    attr_accessor :rtmp_ingest_buffer_time_ms

    attr_accessor :h265_encoder_preset

    attr_accessor :h265_encoder_profile

    attr_accessor :h265_encoder_rc

    attr_accessor :h265_encoder_specific

    attr_accessor :h265_encoder_level

    attr_accessor :height_rtmp_forwarding

    attr_accessor :audio_bitrate_sfu

    attr_accessor :dash_muxing_enabled

    attr_accessor :aac_encoding_enabled

    attr_accessor :gop_size

    attr_accessor :constant_rate_factor

    attr_accessor :web_rtc_viewer_limit

    attr_accessor :to_be_deleted

    attr_accessor :pull_war_file

    attr_accessor :war_file_origin_server_address

    attr_accessor :jwt_secret_key

    attr_accessor :jwt_control_enabled

    attr_accessor :ip_filter_enabled

    attr_accessor :ingesting_stream_limit

    attr_accessor :web_rtc_keyframe_time

    attr_accessor :jwt_stream_secret_key

    attr_accessor :publish_jwt_control_enabled

    attr_accessor :play_jwt_control_enabled

    attr_accessor :dash_http_streaming

    attr_accessor :s3_streams_folder_path

    attr_accessor :s3_previews_folder_path

    attr_accessor :dash_http_endpoint

    attr_accessor :hls_http_endpoint

    attr_accessor :force_decoding

    attr_accessor :add_original_muxer_into_hls_playlist

    attr_accessor :s3_recording_enabled

    attr_accessor :s3_access_key

    attr_accessor :s3_secret_key

    attr_accessor :s3_bucket_name

    attr_accessor :s3_region_name

    attr_accessor :s3_endpoint

    attr_accessor :s3_permission

    attr_accessor :hls_encryption_key_info_file

    attr_accessor :jwks_url

    attr_accessor :force_aspect_ratio_in_transcoding

    attr_accessor :webhook_authenticate_url

    attr_accessor :max_audio_track_count

    attr_accessor :max_video_track_count

    attr_accessor :content_security_policy_header_value

    attr_accessor :rtmp_playback_enabled

    attr_accessor :origin_edge_idle_timeout

    attr_accessor :add_date_time_to_hls_file_name

    attr_accessor :vod_finish_script

    attr_accessor :encoder_settings

    attr_accessor :data_channel_web_hook

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'remote_allowed_cidr' => :'remoteAllowedCIDR',
        :'mp4_muxing_enabled' => :'mp4MuxingEnabled',
        :'web_m_muxing_enabled' => :'webMMuxingEnabled',
        :'add_date_time_to_mp4_file_name' => :'addDateTimeToMp4FileName',
        :'file_name_format' => :'fileNameFormat',
        :'hls_muxing_enabled' => :'hlsMuxingEnabled',
        :'encoder_settings_string' => :'encoderSettingsString',
        :'signaling_enabled' => :'signalingEnabled',
        :'signaling_address' => :'signalingAddress',
        :'hls_list_size' => :'hlsListSize',
        :'hls_time' => :'hlsTime',
        :'upload_extensions_to_s3' => :'uploadExtensionsToS3',
        :'s3_storage_class' => :'s3StorageClass',
        :'endpoint_health_check_period_ms' => :'endpointHealthCheckPeriodMs',
        :'endpoint_republish_limit' => :'endpointRepublishLimit',
        :'dash_seg_duration' => :'dashSegDuration',
        :'dash_fragment_duration' => :'dashFragmentDuration',
        :'target_latency' => :'targetLatency',
        :'dash_window_size' => :'dashWindowSize',
        :'dash_extra_window_size' => :'dashExtraWindowSize',
        :'isl_l_dash_enabled' => :'islLDashEnabled',
        :'isl_lhls_enabled' => :'islLHLSEnabled',
        :'hls_enabled_via_dash' => :'hlsEnabledViaDash',
        :'use_timeline_dash_muxing' => :'useTimelineDashMuxing',
        :'web_rtc_enabled' => :'webRTCEnabled',
        :'use_original_web_rtc_enabled' => :'useOriginalWebRTCEnabled',
        :'delete_hls_files_on_ended' => :'deleteHLSFilesOnEnded',
        :'delete_dash_files_on_ended' => :'deleteDASHFilesOnEnded',
        :'token_hash_secret' => :'tokenHashSecret',
        :'hash_control_publish_enabled' => :'hashControlPublishEnabled',
        :'hash_control_play_enabled' => :'hashControlPlayEnabled',
        :'listener_hook_url' => :'listenerHookURL',
        :'accept_only_streams_in_data_store' => :'acceptOnlyStreamsInDataStore',
        :'accept_only_rooms_in_data_store' => :'acceptOnlyRoomsInDataStore',
        :'publish_token_control_enabled' => :'publishTokenControlEnabled',
        :'play_token_control_enabled' => :'playTokenControlEnabled',
        :'time_token_subscriber_only' => :'timeTokenSubscriberOnly',
        :'enable_time_token_for_play' => :'enableTimeTokenForPlay',
        :'enable_time_token_for_publish' => :'enableTimeTokenForPublish',
        :'time_token_period' => :'timeTokenPeriod',
        :'hls_play_list_type' => :'hlsPlayListType',
        :'vod_folder' => :'vodFolder',
        :'preview_overwrite' => :'previewOverwrite',
        :'stalker_db_server' => :'stalkerDBServer',
        :'stalker_db_username' => :'stalkerDBUsername',
        :'stalker_db_password' => :'stalkerDBPassword',
        :'object_detection_enabled' => :'objectDetectionEnabled',
        :'create_preview_period' => :'createPreviewPeriod',
        :'restart_stream_fetcher_period' => :'restartStreamFetcherPeriod',
        :'start_stream_fetcher_automatically' => :'startStreamFetcherAutomatically',
        :'stream_fetcher_buffer_time' => :'streamFetcherBufferTime',
        :'hlsflags' => :'hlsflags',
        :'my_sql_client_path' => :'mySqlClientPath',
        :'muxer_finish_script' => :'muxerFinishScript',
        :'web_rtc_frame_rate' => :'webRTCFrameRate',
        :'web_rtc_port_range_min' => :'webRTCPortRangeMin',
        :'web_rtc_port_range_max' => :'webRTCPortRangeMax',
        :'stun_server_uri' => :'stunServerURI',
        :'turn_server_username' => :'turnServerUsername',
        :'turn_server_credential' => :'turnServerCredential',
        :'web_rtc_tcp_candidates_enabled' => :'webRTCTcpCandidatesEnabled',
        :'web_rtc_sdp_semantics' => :'webRTCSdpSemantics',
        :'port_allocator_flags' => :'portAllocatorFlags',
        :'collect_social_media_activity' => :'collectSocialMediaActivity',
        :'encoder_name' => :'encoderName',
        :'encoder_preset' => :'encoderPreset',
        :'encoder_profile' => :'encoderProfile',
        :'encoder_level' => :'encoderLevel',
        :'encoder_rc' => :'encoderRc',
        :'encoder_specific' => :'encoderSpecific',
        :'encoder_thread_count' => :'encoderThreadCount',
        :'encoder_thread_type' => :'encoderThreadType',
        :'vp8_encoder_speed' => :'vp8EncoderSpeed',
        :'vp8_encoder_deadline' => :'vp8EncoderDeadline',
        :'vp8_encoder_thread_count' => :'vp8EncoderThreadCount',
        :'preview_height' => :'previewHeight',
        :'generate_preview' => :'generatePreview',
        :'write_stats_to_datastore' => :'writeStatsToDatastore',
        :'encoder_selection_preference' => :'encoderSelectionPreference',
        :'allowed_publisher_cidr' => :'allowedPublisherCIDR',
        :'excessive_bandwidth_value' => :'excessiveBandwidthValue',
        :'excessive_bandwidth_call_threshold' => :'excessiveBandwidthCallThreshold',
        :'excessive_bandwith_try_count_before_switchback' => :'excessiveBandwithTryCountBeforeSwitchback',
        :'excessive_bandwidth_algorithm_enabled' => :'excessiveBandwidthAlgorithmEnabled',
        :'packet_loss_diff_threshold_for_switchback' => :'packetLossDiffThresholdForSwitchback',
        :'rtt_measurement_diff_threshold_for_switchback' => :'rttMeasurementDiffThresholdForSwitchback',
        :'replace_candidate_addr_with_server_addr' => :'replaceCandidateAddrWithServerAddr',
        :'app_name' => :'appName',
        :'encoding_timeout' => :'encodingTimeout',
        :'web_rtc_client_start_timeout_ms' => :'webRTCClientStartTimeoutMs',
        :'default_decoders_enabled' => :'defaultDecodersEnabled',
        :'update_time' => :'updateTime',
        :'http_forwarding_extension' => :'httpForwardingExtension',
        :'http_forwarding_base_url' => :'httpForwardingBaseURL',
        :'max_analyze_duration_ms' => :'maxAnalyzeDurationMS',
        :'disable_ipv6_candidates' => :'disableIPv6Candidates',
        :'rtsp_pull_transport_type' => :'rtspPullTransportType',
        :'rtsp_timeout_duration_ms' => :'rtspTimeoutDurationMs',
        :'max_resolution_accept' => :'maxResolutionAccept',
        :'h264_enabled' => :'h264Enabled',
        :'vp8_enabled' => :'vp8Enabled',
        :'h265_enabled' => :'h265Enabled',
        :'data_channel_enabled' => :'dataChannelEnabled',
        :'data_channel_player_distribution' => :'dataChannelPlayerDistribution',
        :'rtmp_ingest_buffer_time_ms' => :'rtmpIngestBufferTimeMs',
        :'h265_encoder_preset' => :'h265EncoderPreset',
        :'h265_encoder_profile' => :'h265EncoderProfile',
        :'h265_encoder_rc' => :'h265EncoderRc',
        :'h265_encoder_specific' => :'h265EncoderSpecific',
        :'h265_encoder_level' => :'h265EncoderLevel',
        :'height_rtmp_forwarding' => :'heightRtmpForwarding',
        :'audio_bitrate_sfu' => :'audioBitrateSFU',
        :'dash_muxing_enabled' => :'dashMuxingEnabled',
        :'aac_encoding_enabled' => :'aacEncodingEnabled',
        :'gop_size' => :'gopSize',
        :'constant_rate_factor' => :'constantRateFactor',
        :'web_rtc_viewer_limit' => :'webRTCViewerLimit',
        :'to_be_deleted' => :'toBeDeleted',
        :'pull_war_file' => :'pullWarFile',
        :'war_file_origin_server_address' => :'warFileOriginServerAddress',
        :'jwt_secret_key' => :'jwtSecretKey',
        :'jwt_control_enabled' => :'jwtControlEnabled',
        :'ip_filter_enabled' => :'ipFilterEnabled',
        :'ingesting_stream_limit' => :'ingestingStreamLimit',
        :'web_rtc_keyframe_time' => :'webRTCKeyframeTime',
        :'jwt_stream_secret_key' => :'jwtStreamSecretKey',
        :'publish_jwt_control_enabled' => :'publishJwtControlEnabled',
        :'play_jwt_control_enabled' => :'playJwtControlEnabled',
        :'dash_http_streaming' => :'dashHttpStreaming',
        :'s3_streams_folder_path' => :'s3StreamsFolderPath',
        :'s3_previews_folder_path' => :'s3PreviewsFolderPath',
        :'dash_http_endpoint' => :'dashHttpEndpoint',
        :'hls_http_endpoint' => :'hlsHttpEndpoint',
        :'force_decoding' => :'forceDecoding',
        :'add_original_muxer_into_hls_playlist' => :'addOriginalMuxerIntoHLSPlaylist',
        :'s3_recording_enabled' => :'s3RecordingEnabled',
        :'s3_access_key' => :'s3AccessKey',
        :'s3_secret_key' => :'s3SecretKey',
        :'s3_bucket_name' => :'s3BucketName',
        :'s3_region_name' => :'s3RegionName',
        :'s3_endpoint' => :'s3Endpoint',
        :'s3_permission' => :'s3Permission',
        :'hls_encryption_key_info_file' => :'hlsEncryptionKeyInfoFile',
        :'jwks_url' => :'jwksURL',
        :'force_aspect_ratio_in_transcoding' => :'forceAspectRatioInTranscoding',
        :'webhook_authenticate_url' => :'webhookAuthenticateURL',
        :'max_audio_track_count' => :'maxAudioTrackCount',
        :'max_video_track_count' => :'maxVideoTrackCount',
        :'content_security_policy_header_value' => :'contentSecurityPolicyHeaderValue',
        :'rtmp_playback_enabled' => :'rtmpPlaybackEnabled',
        :'origin_edge_idle_timeout' => :'originEdgeIdleTimeout',
        :'add_date_time_to_hls_file_name' => :'addDateTimeToHlsFileName',
        :'vod_finish_script' => :'vodFinishScript',
        :'encoder_settings' => :'encoderSettings',
        :'data_channel_web_hook' => :'dataChannelWebHook'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'remote_allowed_cidr' => :'String',
        :'mp4_muxing_enabled' => :'BOOLEAN',
        :'web_m_muxing_enabled' => :'BOOLEAN',
        :'add_date_time_to_mp4_file_name' => :'BOOLEAN',
        :'file_name_format' => :'String',
        :'hls_muxing_enabled' => :'BOOLEAN',
        :'encoder_settings_string' => :'String',
        :'signaling_enabled' => :'BOOLEAN',
        :'signaling_address' => :'String',
        :'hls_list_size' => :'String',
        :'hls_time' => :'String',
        :'upload_extensions_to_s3' => :'Integer',
        :'s3_storage_class' => :'String',
        :'endpoint_health_check_period_ms' => :'Integer',
        :'endpoint_republish_limit' => :'Integer',
        :'dash_seg_duration' => :'String',
        :'dash_fragment_duration' => :'String',
        :'target_latency' => :'String',
        :'dash_window_size' => :'String',
        :'dash_extra_window_size' => :'String',
        :'isl_l_dash_enabled' => :'BOOLEAN',
        :'isl_lhls_enabled' => :'BOOLEAN',
        :'hls_enabled_via_dash' => :'BOOLEAN',
        :'use_timeline_dash_muxing' => :'BOOLEAN',
        :'web_rtc_enabled' => :'BOOLEAN',
        :'use_original_web_rtc_enabled' => :'BOOLEAN',
        :'delete_hls_files_on_ended' => :'BOOLEAN',
        :'delete_dash_files_on_ended' => :'BOOLEAN',
        :'token_hash_secret' => :'String',
        :'hash_control_publish_enabled' => :'BOOLEAN',
        :'hash_control_play_enabled' => :'BOOLEAN',
        :'listener_hook_url' => :'String',
        :'accept_only_streams_in_data_store' => :'BOOLEAN',
        :'accept_only_rooms_in_data_store' => :'BOOLEAN',
        :'publish_token_control_enabled' => :'BOOLEAN',
        :'play_token_control_enabled' => :'BOOLEAN',
        :'time_token_subscriber_only' => :'BOOLEAN',
        :'enable_time_token_for_play' => :'BOOLEAN',
        :'enable_time_token_for_publish' => :'BOOLEAN',
        :'time_token_period' => :'Integer',
        :'hls_play_list_type' => :'String',
        :'vod_folder' => :'String',
        :'preview_overwrite' => :'BOOLEAN',
        :'stalker_db_server' => :'String',
        :'stalker_db_username' => :'String',
        :'stalker_db_password' => :'String',
        :'object_detection_enabled' => :'BOOLEAN',
        :'create_preview_period' => :'Integer',
        :'restart_stream_fetcher_period' => :'Integer',
        :'start_stream_fetcher_automatically' => :'BOOLEAN',
        :'stream_fetcher_buffer_time' => :'Integer',
        :'hlsflags' => :'String',
        :'my_sql_client_path' => :'String',
        :'muxer_finish_script' => :'String',
        :'web_rtc_frame_rate' => :'Integer',
        :'web_rtc_port_range_min' => :'Integer',
        :'web_rtc_port_range_max' => :'Integer',
        :'stun_server_uri' => :'String',
        :'turn_server_username' => :'String',
        :'turn_server_credential' => :'String',
        :'web_rtc_tcp_candidates_enabled' => :'BOOLEAN',
        :'web_rtc_sdp_semantics' => :'String',
        :'port_allocator_flags' => :'Integer',
        :'collect_social_media_activity' => :'BOOLEAN',
        :'encoder_name' => :'String',
        :'encoder_preset' => :'String',
        :'encoder_profile' => :'String',
        :'encoder_level' => :'String',
        :'encoder_rc' => :'String',
        :'encoder_specific' => :'String',
        :'encoder_thread_count' => :'Integer',
        :'encoder_thread_type' => :'Integer',
        :'vp8_encoder_speed' => :'Integer',
        :'vp8_encoder_deadline' => :'String',
        :'vp8_encoder_thread_count' => :'Integer',
        :'preview_height' => :'Integer',
        :'generate_preview' => :'BOOLEAN',
        :'write_stats_to_datastore' => :'BOOLEAN',
        :'encoder_selection_preference' => :'String',
        :'allowed_publisher_cidr' => :'String',
        :'excessive_bandwidth_value' => :'Integer',
        :'excessive_bandwidth_call_threshold' => :'Integer',
        :'excessive_bandwith_try_count_before_switchback' => :'Integer',
        :'excessive_bandwidth_algorithm_enabled' => :'BOOLEAN',
        :'packet_loss_diff_threshold_for_switchback' => :'Integer',
        :'rtt_measurement_diff_threshold_for_switchback' => :'Integer',
        :'replace_candidate_addr_with_server_addr' => :'BOOLEAN',
        :'app_name' => :'String',
        :'encoding_timeout' => :'Integer',
        :'web_rtc_client_start_timeout_ms' => :'Integer',
        :'default_decoders_enabled' => :'BOOLEAN',
        :'update_time' => :'Integer',
        :'http_forwarding_extension' => :'String',
        :'http_forwarding_base_url' => :'String',
        :'max_analyze_duration_ms' => :'Integer',
        :'disable_ipv6_candidates' => :'BOOLEAN',
        :'rtsp_pull_transport_type' => :'String',
        :'rtsp_timeout_duration_ms' => :'Integer',
        :'max_resolution_accept' => :'Integer',
        :'h264_enabled' => :'BOOLEAN',
        :'vp8_enabled' => :'BOOLEAN',
        :'h265_enabled' => :'BOOLEAN',
        :'data_channel_enabled' => :'BOOLEAN',
        :'data_channel_player_distribution' => :'String',
        :'rtmp_ingest_buffer_time_ms' => :'Integer',
        :'h265_encoder_preset' => :'String',
        :'h265_encoder_profile' => :'String',
        :'h265_encoder_rc' => :'String',
        :'h265_encoder_specific' => :'String',
        :'h265_encoder_level' => :'String',
        :'height_rtmp_forwarding' => :'Integer',
        :'audio_bitrate_sfu' => :'Integer',
        :'dash_muxing_enabled' => :'BOOLEAN',
        :'aac_encoding_enabled' => :'BOOLEAN',
        :'gop_size' => :'Integer',
        :'constant_rate_factor' => :'String',
        :'web_rtc_viewer_limit' => :'Integer',
        :'to_be_deleted' => :'BOOLEAN',
        :'pull_war_file' => :'BOOLEAN',
        :'war_file_origin_server_address' => :'String',
        :'jwt_secret_key' => :'String',
        :'jwt_control_enabled' => :'BOOLEAN',
        :'ip_filter_enabled' => :'BOOLEAN',
        :'ingesting_stream_limit' => :'Integer',
        :'web_rtc_keyframe_time' => :'Integer',
        :'jwt_stream_secret_key' => :'String',
        :'publish_jwt_control_enabled' => :'BOOLEAN',
        :'play_jwt_control_enabled' => :'BOOLEAN',
        :'dash_http_streaming' => :'BOOLEAN',
        :'s3_streams_folder_path' => :'String',
        :'s3_previews_folder_path' => :'String',
        :'dash_http_endpoint' => :'String',
        :'hls_http_endpoint' => :'String',
        :'force_decoding' => :'BOOLEAN',
        :'add_original_muxer_into_hls_playlist' => :'BOOLEAN',
        :'s3_recording_enabled' => :'BOOLEAN',
        :'s3_access_key' => :'String',
        :'s3_secret_key' => :'String',
        :'s3_bucket_name' => :'String',
        :'s3_region_name' => :'String',
        :'s3_endpoint' => :'String',
        :'s3_permission' => :'String',
        :'hls_encryption_key_info_file' => :'String',
        :'jwks_url' => :'String',
        :'force_aspect_ratio_in_transcoding' => :'BOOLEAN',
        :'webhook_authenticate_url' => :'String',
        :'max_audio_track_count' => :'Integer',
        :'max_video_track_count' => :'Integer',
        :'content_security_policy_header_value' => :'String',
        :'rtmp_playback_enabled' => :'BOOLEAN',
        :'origin_edge_idle_timeout' => :'Integer',
        :'add_date_time_to_hls_file_name' => :'BOOLEAN',
        :'vod_finish_script' => :'String',
        :'encoder_settings' => :'Array<EncoderSettings>',
        :'data_channel_web_hook' => :'String'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'remoteAllowedCIDR')
        self.remote_allowed_cidr = attributes[:'remoteAllowedCIDR']
      end

      if attributes.has_key?(:'mp4MuxingEnabled')
        self.mp4_muxing_enabled = attributes[:'mp4MuxingEnabled']
      end

      if attributes.has_key?(:'webMMuxingEnabled')
        self.web_m_muxing_enabled = attributes[:'webMMuxingEnabled']
      end

      if attributes.has_key?(:'addDateTimeToMp4FileName')
        self.add_date_time_to_mp4_file_name = attributes[:'addDateTimeToMp4FileName']
      end

      if attributes.has_key?(:'fileNameFormat')
        self.file_name_format = attributes[:'fileNameFormat']
      end

      if attributes.has_key?(:'hlsMuxingEnabled')
        self.hls_muxing_enabled = attributes[:'hlsMuxingEnabled']
      end

      if attributes.has_key?(:'encoderSettingsString')
        self.encoder_settings_string = attributes[:'encoderSettingsString']
      end

      if attributes.has_key?(:'signalingEnabled')
        self.signaling_enabled = attributes[:'signalingEnabled']
      end

      if attributes.has_key?(:'signalingAddress')
        self.signaling_address = attributes[:'signalingAddress']
      end

      if attributes.has_key?(:'hlsListSize')
        self.hls_list_size = attributes[:'hlsListSize']
      end

      if attributes.has_key?(:'hlsTime')
        self.hls_time = attributes[:'hlsTime']
      end

      if attributes.has_key?(:'uploadExtensionsToS3')
        self.upload_extensions_to_s3 = attributes[:'uploadExtensionsToS3']
      end

      if attributes.has_key?(:'s3StorageClass')
        self.s3_storage_class = attributes[:'s3StorageClass']
      end

      if attributes.has_key?(:'endpointHealthCheckPeriodMs')
        self.endpoint_health_check_period_ms = attributes[:'endpointHealthCheckPeriodMs']
      end

      if attributes.has_key?(:'endpointRepublishLimit')
        self.endpoint_republish_limit = attributes[:'endpointRepublishLimit']
      end

      if attributes.has_key?(:'dashSegDuration')
        self.dash_seg_duration = attributes[:'dashSegDuration']
      end

      if attributes.has_key?(:'dashFragmentDuration')
        self.dash_fragment_duration = attributes[:'dashFragmentDuration']
      end

      if attributes.has_key?(:'targetLatency')
        self.target_latency = attributes[:'targetLatency']
      end

      if attributes.has_key?(:'dashWindowSize')
        self.dash_window_size = attributes[:'dashWindowSize']
      end

      if attributes.has_key?(:'dashExtraWindowSize')
        self.dash_extra_window_size = attributes[:'dashExtraWindowSize']
      end

      if attributes.has_key?(:'islLDashEnabled')
        self.isl_l_dash_enabled = attributes[:'islLDashEnabled']
      end

      if attributes.has_key?(:'islLHLSEnabled')
        self.isl_lhls_enabled = attributes[:'islLHLSEnabled']
      end

      if attributes.has_key?(:'hlsEnabledViaDash')
        self.hls_enabled_via_dash = attributes[:'hlsEnabledViaDash']
      end

      if attributes.has_key?(:'useTimelineDashMuxing')
        self.use_timeline_dash_muxing = attributes[:'useTimelineDashMuxing']
      end

      if attributes.has_key?(:'webRTCEnabled')
        self.web_rtc_enabled = attributes[:'webRTCEnabled']
      end

      if attributes.has_key?(:'useOriginalWebRTCEnabled')
        self.use_original_web_rtc_enabled = attributes[:'useOriginalWebRTCEnabled']
      end

      if attributes.has_key?(:'deleteHLSFilesOnEnded')
        self.delete_hls_files_on_ended = attributes[:'deleteHLSFilesOnEnded']
      end

      if attributes.has_key?(:'deleteDASHFilesOnEnded')
        self.delete_dash_files_on_ended = attributes[:'deleteDASHFilesOnEnded']
      end

      if attributes.has_key?(:'tokenHashSecret')
        self.token_hash_secret = attributes[:'tokenHashSecret']
      end

      if attributes.has_key?(:'hashControlPublishEnabled')
        self.hash_control_publish_enabled = attributes[:'hashControlPublishEnabled']
      end

      if attributes.has_key?(:'hashControlPlayEnabled')
        self.hash_control_play_enabled = attributes[:'hashControlPlayEnabled']
      end

      if attributes.has_key?(:'listenerHookURL')
        self.listener_hook_url = attributes[:'listenerHookURL']
      end

      if attributes.has_key?(:'acceptOnlyStreamsInDataStore')
        self.accept_only_streams_in_data_store = attributes[:'acceptOnlyStreamsInDataStore']
      end

      if attributes.has_key?(:'acceptOnlyRoomsInDataStore')
        self.accept_only_rooms_in_data_store = attributes[:'acceptOnlyRoomsInDataStore']
      end

      if attributes.has_key?(:'publishTokenControlEnabled')
        self.publish_token_control_enabled = attributes[:'publishTokenControlEnabled']
      end

      if attributes.has_key?(:'playTokenControlEnabled')
        self.play_token_control_enabled = attributes[:'playTokenControlEnabled']
      end

      if attributes.has_key?(:'timeTokenSubscriberOnly')
        self.time_token_subscriber_only = attributes[:'timeTokenSubscriberOnly']
      end

      if attributes.has_key?(:'enableTimeTokenForPlay')
        self.enable_time_token_for_play = attributes[:'enableTimeTokenForPlay']
      end

      if attributes.has_key?(:'enableTimeTokenForPublish')
        self.enable_time_token_for_publish = attributes[:'enableTimeTokenForPublish']
      end

      if attributes.has_key?(:'timeTokenPeriod')
        self.time_token_period = attributes[:'timeTokenPeriod']
      end

      if attributes.has_key?(:'hlsPlayListType')
        self.hls_play_list_type = attributes[:'hlsPlayListType']
      end

      if attributes.has_key?(:'vodFolder')
        self.vod_folder = attributes[:'vodFolder']
      end

      if attributes.has_key?(:'previewOverwrite')
        self.preview_overwrite = attributes[:'previewOverwrite']
      end

      if attributes.has_key?(:'stalkerDBServer')
        self.stalker_db_server = attributes[:'stalkerDBServer']
      end

      if attributes.has_key?(:'stalkerDBUsername')
        self.stalker_db_username = attributes[:'stalkerDBUsername']
      end

      if attributes.has_key?(:'stalkerDBPassword')
        self.stalker_db_password = attributes[:'stalkerDBPassword']
      end

      if attributes.has_key?(:'objectDetectionEnabled')
        self.object_detection_enabled = attributes[:'objectDetectionEnabled']
      end

      if attributes.has_key?(:'createPreviewPeriod')
        self.create_preview_period = attributes[:'createPreviewPeriod']
      end

      if attributes.has_key?(:'restartStreamFetcherPeriod')
        self.restart_stream_fetcher_period = attributes[:'restartStreamFetcherPeriod']
      end

      if attributes.has_key?(:'startStreamFetcherAutomatically')
        self.start_stream_fetcher_automatically = attributes[:'startStreamFetcherAutomatically']
      end

      if attributes.has_key?(:'streamFetcherBufferTime')
        self.stream_fetcher_buffer_time = attributes[:'streamFetcherBufferTime']
      end

      if attributes.has_key?(:'hlsflags')
        self.hlsflags = attributes[:'hlsflags']
      end

      if attributes.has_key?(:'mySqlClientPath')
        self.my_sql_client_path = attributes[:'mySqlClientPath']
      end

      if attributes.has_key?(:'muxerFinishScript')
        self.muxer_finish_script = attributes[:'muxerFinishScript']
      end

      if attributes.has_key?(:'webRTCFrameRate')
        self.web_rtc_frame_rate = attributes[:'webRTCFrameRate']
      end

      if attributes.has_key?(:'webRTCPortRangeMin')
        self.web_rtc_port_range_min = attributes[:'webRTCPortRangeMin']
      end

      if attributes.has_key?(:'webRTCPortRangeMax')
        self.web_rtc_port_range_max = attributes[:'webRTCPortRangeMax']
      end

      if attributes.has_key?(:'stunServerURI')
        self.stun_server_uri = attributes[:'stunServerURI']
      end

      if attributes.has_key?(:'turnServerUsername')
        self.turn_server_username = attributes[:'turnServerUsername']
      end

      if attributes.has_key?(:'turnServerCredential')
        self.turn_server_credential = attributes[:'turnServerCredential']
      end

      if attributes.has_key?(:'webRTCTcpCandidatesEnabled')
        self.web_rtc_tcp_candidates_enabled = attributes[:'webRTCTcpCandidatesEnabled']
      end

      if attributes.has_key?(:'webRTCSdpSemantics')
        self.web_rtc_sdp_semantics = attributes[:'webRTCSdpSemantics']
      end

      if attributes.has_key?(:'portAllocatorFlags')
        self.port_allocator_flags = attributes[:'portAllocatorFlags']
      end

      if attributes.has_key?(:'collectSocialMediaActivity')
        self.collect_social_media_activity = attributes[:'collectSocialMediaActivity']
      end

      if attributes.has_key?(:'encoderName')
        self.encoder_name = attributes[:'encoderName']
      end

      if attributes.has_key?(:'encoderPreset')
        self.encoder_preset = attributes[:'encoderPreset']
      end

      if attributes.has_key?(:'encoderProfile')
        self.encoder_profile = attributes[:'encoderProfile']
      end

      if attributes.has_key?(:'encoderLevel')
        self.encoder_level = attributes[:'encoderLevel']
      end

      if attributes.has_key?(:'encoderRc')
        self.encoder_rc = attributes[:'encoderRc']
      end

      if attributes.has_key?(:'encoderSpecific')
        self.encoder_specific = attributes[:'encoderSpecific']
      end

      if attributes.has_key?(:'encoderThreadCount')
        self.encoder_thread_count = attributes[:'encoderThreadCount']
      end

      if attributes.has_key?(:'encoderThreadType')
        self.encoder_thread_type = attributes[:'encoderThreadType']
      end

      if attributes.has_key?(:'vp8EncoderSpeed')
        self.vp8_encoder_speed = attributes[:'vp8EncoderSpeed']
      end

      if attributes.has_key?(:'vp8EncoderDeadline')
        self.vp8_encoder_deadline = attributes[:'vp8EncoderDeadline']
      end

      if attributes.has_key?(:'vp8EncoderThreadCount')
        self.vp8_encoder_thread_count = attributes[:'vp8EncoderThreadCount']
      end

      if attributes.has_key?(:'previewHeight')
        self.preview_height = attributes[:'previewHeight']
      end

      if attributes.has_key?(:'generatePreview')
        self.generate_preview = attributes[:'generatePreview']
      end

      if attributes.has_key?(:'writeStatsToDatastore')
        self.write_stats_to_datastore = attributes[:'writeStatsToDatastore']
      end

      if attributes.has_key?(:'encoderSelectionPreference')
        self.encoder_selection_preference = attributes[:'encoderSelectionPreference']
      end

      if attributes.has_key?(:'allowedPublisherCIDR')
        self.allowed_publisher_cidr = attributes[:'allowedPublisherCIDR']
      end

      if attributes.has_key?(:'excessiveBandwidthValue')
        self.excessive_bandwidth_value = attributes[:'excessiveBandwidthValue']
      end

      if attributes.has_key?(:'excessiveBandwidthCallThreshold')
        self.excessive_bandwidth_call_threshold = attributes[:'excessiveBandwidthCallThreshold']
      end

      if attributes.has_key?(:'excessiveBandwithTryCountBeforeSwitchback')
        self.excessive_bandwith_try_count_before_switchback = attributes[:'excessiveBandwithTryCountBeforeSwitchback']
      end

      if attributes.has_key?(:'excessiveBandwidthAlgorithmEnabled')
        self.excessive_bandwidth_algorithm_enabled = attributes[:'excessiveBandwidthAlgorithmEnabled']
      end

      if attributes.has_key?(:'packetLossDiffThresholdForSwitchback')
        self.packet_loss_diff_threshold_for_switchback = attributes[:'packetLossDiffThresholdForSwitchback']
      end

      if attributes.has_key?(:'rttMeasurementDiffThresholdForSwitchback')
        self.rtt_measurement_diff_threshold_for_switchback = attributes[:'rttMeasurementDiffThresholdForSwitchback']
      end

      if attributes.has_key?(:'replaceCandidateAddrWithServerAddr')
        self.replace_candidate_addr_with_server_addr = attributes[:'replaceCandidateAddrWithServerAddr']
      end

      if attributes.has_key?(:'appName')
        self.app_name = attributes[:'appName']
      end

      if attributes.has_key?(:'encodingTimeout')
        self.encoding_timeout = attributes[:'encodingTimeout']
      end

      if attributes.has_key?(:'webRTCClientStartTimeoutMs')
        self.web_rtc_client_start_timeout_ms = attributes[:'webRTCClientStartTimeoutMs']
      end

      if attributes.has_key?(:'defaultDecodersEnabled')
        self.default_decoders_enabled = attributes[:'defaultDecodersEnabled']
      end

      if attributes.has_key?(:'updateTime')
        self.update_time = attributes[:'updateTime']
      end

      if attributes.has_key?(:'httpForwardingExtension')
        self.http_forwarding_extension = attributes[:'httpForwardingExtension']
      end

      if attributes.has_key?(:'httpForwardingBaseURL')
        self.http_forwarding_base_url = attributes[:'httpForwardingBaseURL']
      end

      if attributes.has_key?(:'maxAnalyzeDurationMS')
        self.max_analyze_duration_ms = attributes[:'maxAnalyzeDurationMS']
      end

      if attributes.has_key?(:'disableIPv6Candidates')
        self.disable_ipv6_candidates = attributes[:'disableIPv6Candidates']
      end

      if attributes.has_key?(:'rtspPullTransportType')
        self.rtsp_pull_transport_type = attributes[:'rtspPullTransportType']
      end

      if attributes.has_key?(:'rtspTimeoutDurationMs')
        self.rtsp_timeout_duration_ms = attributes[:'rtspTimeoutDurationMs']
      end

      if attributes.has_key?(:'maxResolutionAccept')
        self.max_resolution_accept = attributes[:'maxResolutionAccept']
      end

      if attributes.has_key?(:'h264Enabled')
        self.h264_enabled = attributes[:'h264Enabled']
      end

      if attributes.has_key?(:'vp8Enabled')
        self.vp8_enabled = attributes[:'vp8Enabled']
      end

      if attributes.has_key?(:'h265Enabled')
        self.h265_enabled = attributes[:'h265Enabled']
      end

      if attributes.has_key?(:'dataChannelEnabled')
        self.data_channel_enabled = attributes[:'dataChannelEnabled']
      end

      if attributes.has_key?(:'dataChannelPlayerDistribution')
        self.data_channel_player_distribution = attributes[:'dataChannelPlayerDistribution']
      end

      if attributes.has_key?(:'rtmpIngestBufferTimeMs')
        self.rtmp_ingest_buffer_time_ms = attributes[:'rtmpIngestBufferTimeMs']
      end

      if attributes.has_key?(:'h265EncoderPreset')
        self.h265_encoder_preset = attributes[:'h265EncoderPreset']
      end

      if attributes.has_key?(:'h265EncoderProfile')
        self.h265_encoder_profile = attributes[:'h265EncoderProfile']
      end

      if attributes.has_key?(:'h265EncoderRc')
        self.h265_encoder_rc = attributes[:'h265EncoderRc']
      end

      if attributes.has_key?(:'h265EncoderSpecific')
        self.h265_encoder_specific = attributes[:'h265EncoderSpecific']
      end

      if attributes.has_key?(:'h265EncoderLevel')
        self.h265_encoder_level = attributes[:'h265EncoderLevel']
      end

      if attributes.has_key?(:'heightRtmpForwarding')
        self.height_rtmp_forwarding = attributes[:'heightRtmpForwarding']
      end

      if attributes.has_key?(:'audioBitrateSFU')
        self.audio_bitrate_sfu = attributes[:'audioBitrateSFU']
      end

      if attributes.has_key?(:'dashMuxingEnabled')
        self.dash_muxing_enabled = attributes[:'dashMuxingEnabled']
      end

      if attributes.has_key?(:'aacEncodingEnabled')
        self.aac_encoding_enabled = attributes[:'aacEncodingEnabled']
      end

      if attributes.has_key?(:'gopSize')
        self.gop_size = attributes[:'gopSize']
      end

      if attributes.has_key?(:'constantRateFactor')
        self.constant_rate_factor = attributes[:'constantRateFactor']
      end

      if attributes.has_key?(:'webRTCViewerLimit')
        self.web_rtc_viewer_limit = attributes[:'webRTCViewerLimit']
      end

      if attributes.has_key?(:'toBeDeleted')
        self.to_be_deleted = attributes[:'toBeDeleted']
      end

      if attributes.has_key?(:'pullWarFile')
        self.pull_war_file = attributes[:'pullWarFile']
      end

      if attributes.has_key?(:'warFileOriginServerAddress')
        self.war_file_origin_server_address = attributes[:'warFileOriginServerAddress']
      end

      if attributes.has_key?(:'jwtSecretKey')
        self.jwt_secret_key = attributes[:'jwtSecretKey']
      end

      if attributes.has_key?(:'jwtControlEnabled')
        self.jwt_control_enabled = attributes[:'jwtControlEnabled']
      end

      if attributes.has_key?(:'ipFilterEnabled')
        self.ip_filter_enabled = attributes[:'ipFilterEnabled']
      end

      if attributes.has_key?(:'ingestingStreamLimit')
        self.ingesting_stream_limit = attributes[:'ingestingStreamLimit']
      end

      if attributes.has_key?(:'webRTCKeyframeTime')
        self.web_rtc_keyframe_time = attributes[:'webRTCKeyframeTime']
      end

      if attributes.has_key?(:'jwtStreamSecretKey')
        self.jwt_stream_secret_key = attributes[:'jwtStreamSecretKey']
      end

      if attributes.has_key?(:'publishJwtControlEnabled')
        self.publish_jwt_control_enabled = attributes[:'publishJwtControlEnabled']
      end

      if attributes.has_key?(:'playJwtControlEnabled')
        self.play_jwt_control_enabled = attributes[:'playJwtControlEnabled']
      end

      if attributes.has_key?(:'dashHttpStreaming')
        self.dash_http_streaming = attributes[:'dashHttpStreaming']
      end

      if attributes.has_key?(:'s3StreamsFolderPath')
        self.s3_streams_folder_path = attributes[:'s3StreamsFolderPath']
      end

      if attributes.has_key?(:'s3PreviewsFolderPath')
        self.s3_previews_folder_path = attributes[:'s3PreviewsFolderPath']
      end

      if attributes.has_key?(:'dashHttpEndpoint')
        self.dash_http_endpoint = attributes[:'dashHttpEndpoint']
      end

      if attributes.has_key?(:'hlsHttpEndpoint')
        self.hls_http_endpoint = attributes[:'hlsHttpEndpoint']
      end

      if attributes.has_key?(:'forceDecoding')
        self.force_decoding = attributes[:'forceDecoding']
      end

      if attributes.has_key?(:'addOriginalMuxerIntoHLSPlaylist')
        self.add_original_muxer_into_hls_playlist = attributes[:'addOriginalMuxerIntoHLSPlaylist']
      end

      if attributes.has_key?(:'s3RecordingEnabled')
        self.s3_recording_enabled = attributes[:'s3RecordingEnabled']
      end

      if attributes.has_key?(:'s3AccessKey')
        self.s3_access_key = attributes[:'s3AccessKey']
      end

      if attributes.has_key?(:'s3SecretKey')
        self.s3_secret_key = attributes[:'s3SecretKey']
      end

      if attributes.has_key?(:'s3BucketName')
        self.s3_bucket_name = attributes[:'s3BucketName']
      end

      if attributes.has_key?(:'s3RegionName')
        self.s3_region_name = attributes[:'s3RegionName']
      end

      if attributes.has_key?(:'s3Endpoint')
        self.s3_endpoint = attributes[:'s3Endpoint']
      end

      if attributes.has_key?(:'s3Permission')
        self.s3_permission = attributes[:'s3Permission']
      end

      if attributes.has_key?(:'hlsEncryptionKeyInfoFile')
        self.hls_encryption_key_info_file = attributes[:'hlsEncryptionKeyInfoFile']
      end

      if attributes.has_key?(:'jwksURL')
        self.jwks_url = attributes[:'jwksURL']
      end

      if attributes.has_key?(:'forceAspectRatioInTranscoding')
        self.force_aspect_ratio_in_transcoding = attributes[:'forceAspectRatioInTranscoding']
      end

      if attributes.has_key?(:'webhookAuthenticateURL')
        self.webhook_authenticate_url = attributes[:'webhookAuthenticateURL']
      end

      if attributes.has_key?(:'maxAudioTrackCount')
        self.max_audio_track_count = attributes[:'maxAudioTrackCount']
      end

      if attributes.has_key?(:'maxVideoTrackCount')
        self.max_video_track_count = attributes[:'maxVideoTrackCount']
      end

      if attributes.has_key?(:'contentSecurityPolicyHeaderValue')
        self.content_security_policy_header_value = attributes[:'contentSecurityPolicyHeaderValue']
      end

      if attributes.has_key?(:'rtmpPlaybackEnabled')
        self.rtmp_playback_enabled = attributes[:'rtmpPlaybackEnabled']
      end

      if attributes.has_key?(:'originEdgeIdleTimeout')
        self.origin_edge_idle_timeout = attributes[:'originEdgeIdleTimeout']
      end

      if attributes.has_key?(:'addDateTimeToHlsFileName')
        self.add_date_time_to_hls_file_name = attributes[:'addDateTimeToHlsFileName']
      end

      if attributes.has_key?(:'vodFinishScript')
        self.vod_finish_script = attributes[:'vodFinishScript']
      end

      if attributes.has_key?(:'encoderSettings')
        if (value = attributes[:'encoderSettings']).is_a?(Array)
          self.encoder_settings = value
        end
      end

      if attributes.has_key?(:'dataChannelWebHook')
        self.data_channel_web_hook = attributes[:'dataChannelWebHook']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          remote_allowed_cidr == o.remote_allowed_cidr &&
          mp4_muxing_enabled == o.mp4_muxing_enabled &&
          web_m_muxing_enabled == o.web_m_muxing_enabled &&
          add_date_time_to_mp4_file_name == o.add_date_time_to_mp4_file_name &&
          file_name_format == o.file_name_format &&
          hls_muxing_enabled == o.hls_muxing_enabled &&
          encoder_settings_string == o.encoder_settings_string &&
          signaling_enabled == o.signaling_enabled &&
          signaling_address == o.signaling_address &&
          hls_list_size == o.hls_list_size &&
          hls_time == o.hls_time &&
          upload_extensions_to_s3 == o.upload_extensions_to_s3 &&
          s3_storage_class == o.s3_storage_class &&
          endpoint_health_check_period_ms == o.endpoint_health_check_period_ms &&
          endpoint_republish_limit == o.endpoint_republish_limit &&
          dash_seg_duration == o.dash_seg_duration &&
          dash_fragment_duration == o.dash_fragment_duration &&
          target_latency == o.target_latency &&
          dash_window_size == o.dash_window_size &&
          dash_extra_window_size == o.dash_extra_window_size &&
          isl_l_dash_enabled == o.isl_l_dash_enabled &&
          isl_lhls_enabled == o.isl_lhls_enabled &&
          hls_enabled_via_dash == o.hls_enabled_via_dash &&
          use_timeline_dash_muxing == o.use_timeline_dash_muxing &&
          web_rtc_enabled == o.web_rtc_enabled &&
          use_original_web_rtc_enabled == o.use_original_web_rtc_enabled &&
          delete_hls_files_on_ended == o.delete_hls_files_on_ended &&
          delete_dash_files_on_ended == o.delete_dash_files_on_ended &&
          token_hash_secret == o.token_hash_secret &&
          hash_control_publish_enabled == o.hash_control_publish_enabled &&
          hash_control_play_enabled == o.hash_control_play_enabled &&
          listener_hook_url == o.listener_hook_url &&
          accept_only_streams_in_data_store == o.accept_only_streams_in_data_store &&
          accept_only_rooms_in_data_store == o.accept_only_rooms_in_data_store &&
          publish_token_control_enabled == o.publish_token_control_enabled &&
          play_token_control_enabled == o.play_token_control_enabled &&
          time_token_subscriber_only == o.time_token_subscriber_only &&
          enable_time_token_for_play == o.enable_time_token_for_play &&
          enable_time_token_for_publish == o.enable_time_token_for_publish &&
          time_token_period == o.time_token_period &&
          hls_play_list_type == o.hls_play_list_type &&
          vod_folder == o.vod_folder &&
          preview_overwrite == o.preview_overwrite &&
          stalker_db_server == o.stalker_db_server &&
          stalker_db_username == o.stalker_db_username &&
          stalker_db_password == o.stalker_db_password &&
          object_detection_enabled == o.object_detection_enabled &&
          create_preview_period == o.create_preview_period &&
          restart_stream_fetcher_period == o.restart_stream_fetcher_period &&
          start_stream_fetcher_automatically == o.start_stream_fetcher_automatically &&
          stream_fetcher_buffer_time == o.stream_fetcher_buffer_time &&
          hlsflags == o.hlsflags &&
          my_sql_client_path == o.my_sql_client_path &&
          muxer_finish_script == o.muxer_finish_script &&
          web_rtc_frame_rate == o.web_rtc_frame_rate &&
          web_rtc_port_range_min == o.web_rtc_port_range_min &&
          web_rtc_port_range_max == o.web_rtc_port_range_max &&
          stun_server_uri == o.stun_server_uri &&
          turn_server_username == o.turn_server_username &&
          turn_server_credential == o.turn_server_credential &&
          web_rtc_tcp_candidates_enabled == o.web_rtc_tcp_candidates_enabled &&
          web_rtc_sdp_semantics == o.web_rtc_sdp_semantics &&
          port_allocator_flags == o.port_allocator_flags &&
          collect_social_media_activity == o.collect_social_media_activity &&
          encoder_name == o.encoder_name &&
          encoder_preset == o.encoder_preset &&
          encoder_profile == o.encoder_profile &&
          encoder_level == o.encoder_level &&
          encoder_rc == o.encoder_rc &&
          encoder_specific == o.encoder_specific &&
          encoder_thread_count == o.encoder_thread_count &&
          encoder_thread_type == o.encoder_thread_type &&
          vp8_encoder_speed == o.vp8_encoder_speed &&
          vp8_encoder_deadline == o.vp8_encoder_deadline &&
          vp8_encoder_thread_count == o.vp8_encoder_thread_count &&
          preview_height == o.preview_height &&
          generate_preview == o.generate_preview &&
          write_stats_to_datastore == o.write_stats_to_datastore &&
          encoder_selection_preference == o.encoder_selection_preference &&
          allowed_publisher_cidr == o.allowed_publisher_cidr &&
          excessive_bandwidth_value == o.excessive_bandwidth_value &&
          excessive_bandwidth_call_threshold == o.excessive_bandwidth_call_threshold &&
          excessive_bandwith_try_count_before_switchback == o.excessive_bandwith_try_count_before_switchback &&
          excessive_bandwidth_algorithm_enabled == o.excessive_bandwidth_algorithm_enabled &&
          packet_loss_diff_threshold_for_switchback == o.packet_loss_diff_threshold_for_switchback &&
          rtt_measurement_diff_threshold_for_switchback == o.rtt_measurement_diff_threshold_for_switchback &&
          replace_candidate_addr_with_server_addr == o.replace_candidate_addr_with_server_addr &&
          app_name == o.app_name &&
          encoding_timeout == o.encoding_timeout &&
          web_rtc_client_start_timeout_ms == o.web_rtc_client_start_timeout_ms &&
          default_decoders_enabled == o.default_decoders_enabled &&
          update_time == o.update_time &&
          http_forwarding_extension == o.http_forwarding_extension &&
          http_forwarding_base_url == o.http_forwarding_base_url &&
          max_analyze_duration_ms == o.max_analyze_duration_ms &&
          disable_ipv6_candidates == o.disable_ipv6_candidates &&
          rtsp_pull_transport_type == o.rtsp_pull_transport_type &&
          rtsp_timeout_duration_ms == o.rtsp_timeout_duration_ms &&
          max_resolution_accept == o.max_resolution_accept &&
          h264_enabled == o.h264_enabled &&
          vp8_enabled == o.vp8_enabled &&
          h265_enabled == o.h265_enabled &&
          data_channel_enabled == o.data_channel_enabled &&
          data_channel_player_distribution == o.data_channel_player_distribution &&
          rtmp_ingest_buffer_time_ms == o.rtmp_ingest_buffer_time_ms &&
          h265_encoder_preset == o.h265_encoder_preset &&
          h265_encoder_profile == o.h265_encoder_profile &&
          h265_encoder_rc == o.h265_encoder_rc &&
          h265_encoder_specific == o.h265_encoder_specific &&
          h265_encoder_level == o.h265_encoder_level &&
          height_rtmp_forwarding == o.height_rtmp_forwarding &&
          audio_bitrate_sfu == o.audio_bitrate_sfu &&
          dash_muxing_enabled == o.dash_muxing_enabled &&
          aac_encoding_enabled == o.aac_encoding_enabled &&
          gop_size == o.gop_size &&
          constant_rate_factor == o.constant_rate_factor &&
          web_rtc_viewer_limit == o.web_rtc_viewer_limit &&
          to_be_deleted == o.to_be_deleted &&
          pull_war_file == o.pull_war_file &&
          war_file_origin_server_address == o.war_file_origin_server_address &&
          jwt_secret_key == o.jwt_secret_key &&
          jwt_control_enabled == o.jwt_control_enabled &&
          ip_filter_enabled == o.ip_filter_enabled &&
          ingesting_stream_limit == o.ingesting_stream_limit &&
          web_rtc_keyframe_time == o.web_rtc_keyframe_time &&
          jwt_stream_secret_key == o.jwt_stream_secret_key &&
          publish_jwt_control_enabled == o.publish_jwt_control_enabled &&
          play_jwt_control_enabled == o.play_jwt_control_enabled &&
          dash_http_streaming == o.dash_http_streaming &&
          s3_streams_folder_path == o.s3_streams_folder_path &&
          s3_previews_folder_path == o.s3_previews_folder_path &&
          dash_http_endpoint == o.dash_http_endpoint &&
          hls_http_endpoint == o.hls_http_endpoint &&
          force_decoding == o.force_decoding &&
          add_original_muxer_into_hls_playlist == o.add_original_muxer_into_hls_playlist &&
          s3_recording_enabled == o.s3_recording_enabled &&
          s3_access_key == o.s3_access_key &&
          s3_secret_key == o.s3_secret_key &&
          s3_bucket_name == o.s3_bucket_name &&
          s3_region_name == o.s3_region_name &&
          s3_endpoint == o.s3_endpoint &&
          s3_permission == o.s3_permission &&
          hls_encryption_key_info_file == o.hls_encryption_key_info_file &&
          jwks_url == o.jwks_url &&
          force_aspect_ratio_in_transcoding == o.force_aspect_ratio_in_transcoding &&
          webhook_authenticate_url == o.webhook_authenticate_url &&
          max_audio_track_count == o.max_audio_track_count &&
          max_video_track_count == o.max_video_track_count &&
          content_security_policy_header_value == o.content_security_policy_header_value &&
          rtmp_playback_enabled == o.rtmp_playback_enabled &&
          origin_edge_idle_timeout == o.origin_edge_idle_timeout &&
          add_date_time_to_hls_file_name == o.add_date_time_to_hls_file_name &&
          vod_finish_script == o.vod_finish_script &&
          encoder_settings == o.encoder_settings &&
          data_channel_web_hook == o.data_channel_web_hook
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [remote_allowed_cidr, mp4_muxing_enabled, web_m_muxing_enabled, add_date_time_to_mp4_file_name, file_name_format, hls_muxing_enabled, encoder_settings_string, signaling_enabled, signaling_address, hls_list_size, hls_time, upload_extensions_to_s3, s3_storage_class, endpoint_health_check_period_ms, endpoint_republish_limit, dash_seg_duration, dash_fragment_duration, target_latency, dash_window_size, dash_extra_window_size, isl_l_dash_enabled, isl_lhls_enabled, hls_enabled_via_dash, use_timeline_dash_muxing, web_rtc_enabled, use_original_web_rtc_enabled, delete_hls_files_on_ended, delete_dash_files_on_ended, token_hash_secret, hash_control_publish_enabled, hash_control_play_enabled, listener_hook_url, accept_only_streams_in_data_store, accept_only_rooms_in_data_store, publish_token_control_enabled, play_token_control_enabled, time_token_subscriber_only, enable_time_token_for_play, enable_time_token_for_publish, time_token_period, hls_play_list_type, vod_folder, preview_overwrite, stalker_db_server, stalker_db_username, stalker_db_password, object_detection_enabled, create_preview_period, restart_stream_fetcher_period, start_stream_fetcher_automatically, stream_fetcher_buffer_time, hlsflags, my_sql_client_path, muxer_finish_script, web_rtc_frame_rate, web_rtc_port_range_min, web_rtc_port_range_max, stun_server_uri, turn_server_username, turn_server_credential, web_rtc_tcp_candidates_enabled, web_rtc_sdp_semantics, port_allocator_flags, collect_social_media_activity, encoder_name, encoder_preset, encoder_profile, encoder_level, encoder_rc, encoder_specific, encoder_thread_count, encoder_thread_type, vp8_encoder_speed, vp8_encoder_deadline, vp8_encoder_thread_count, preview_height, generate_preview, write_stats_to_datastore, encoder_selection_preference, allowed_publisher_cidr, excessive_bandwidth_value, excessive_bandwidth_call_threshold, excessive_bandwith_try_count_before_switchback, excessive_bandwidth_algorithm_enabled, packet_loss_diff_threshold_for_switchback, rtt_measurement_diff_threshold_for_switchback, replace_candidate_addr_with_server_addr, app_name, encoding_timeout, web_rtc_client_start_timeout_ms, default_decoders_enabled, update_time, http_forwarding_extension, http_forwarding_base_url, max_analyze_duration_ms, disable_ipv6_candidates, rtsp_pull_transport_type, rtsp_timeout_duration_ms, max_resolution_accept, h264_enabled, vp8_enabled, h265_enabled, data_channel_enabled, data_channel_player_distribution, rtmp_ingest_buffer_time_ms, h265_encoder_preset, h265_encoder_profile, h265_encoder_rc, h265_encoder_specific, h265_encoder_level, height_rtmp_forwarding, audio_bitrate_sfu, dash_muxing_enabled, aac_encoding_enabled, gop_size, constant_rate_factor, web_rtc_viewer_limit, to_be_deleted, pull_war_file, war_file_origin_server_address, jwt_secret_key, jwt_control_enabled, ip_filter_enabled, ingesting_stream_limit, web_rtc_keyframe_time, jwt_stream_secret_key, publish_jwt_control_enabled, play_jwt_control_enabled, dash_http_streaming, s3_streams_folder_path, s3_previews_folder_path, dash_http_endpoint, hls_http_endpoint, force_decoding, add_original_muxer_into_hls_playlist, s3_recording_enabled, s3_access_key, s3_secret_key, s3_bucket_name, s3_region_name, s3_endpoint, s3_permission, hls_encryption_key_info_file, jwks_url, force_aspect_ratio_in_transcoding, webhook_authenticate_url, max_audio_track_count, max_video_track_count, content_security_policy_header_value, rtmp_playback_enabled, origin_edge_idle_timeout, add_date_time_to_hls_file_name, vod_finish_script, encoder_settings, data_channel_web_hook].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = AntmediaClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end
end
