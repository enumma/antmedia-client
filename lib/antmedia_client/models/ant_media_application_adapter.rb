=begin
#Ant Media Server REST API Reference

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: 2.5.3

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.31

=end

require 'date'

module AntmediaClient
  class AntMediaApplicationAdapter
    attr_accessor :scope

    attr_accessor :plugins

    attr_accessor :listeners

    attr_accessor :server_settings

    attr_accessor :stream_publish_security_list

    attr_accessor :stream_fetcher_manager

    attr_accessor :mux_adaptors

    attr_accessor :data_store

    attr_accessor :data_store_factory

    attr_accessor :stream_accept_filter

    attr_accessor :app_settings

    attr_accessor :vertx

    attr_accessor :number_of_encoder_not_opened_errors

    attr_accessor :shutdown_properly

    attr_accessor :web_rtc_video_receive_stats

    attr_accessor :web_rtc_audio_receive_stats

    attr_accessor :web_rtc_video_send_stats

    attr_accessor :web_rtc_audio_send_stats

    attr_accessor :server_shutting_down

    attr_accessor :storage_client

    attr_accessor :http_client

    attr_accessor :data_channel_messaging_supported

    attr_accessor :data_channel_enabled

    attr_accessor :number_of_encoders_blocked

    attr_accessor :number_of_publish_timeout_error

    attr_accessor :stream_publish_security

    attr_accessor :stream_playback_security

    attr_accessor :scheduled_job_names

    attr_accessor :client_ttl

    attr_accessor :ghost_conns_cleanup_period

    attr_accessor :name

    attr_accessor :parent

    attr_accessor :context

    attr_accessor :path

    attr_accessor :attributes

    attr_accessor :depth

    attr_accessor :attribute_names

    attr_accessor :clients

    attr_accessor :connections

    attr_accessor :child_scope_names

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'scope' => :'scope',
        :'plugins' => :'plugins',
        :'listeners' => :'listeners',
        :'server_settings' => :'serverSettings',
        :'stream_publish_security_list' => :'streamPublishSecurityList',
        :'stream_fetcher_manager' => :'streamFetcherManager',
        :'mux_adaptors' => :'muxAdaptors',
        :'data_store' => :'dataStore',
        :'data_store_factory' => :'dataStoreFactory',
        :'stream_accept_filter' => :'streamAcceptFilter',
        :'app_settings' => :'appSettings',
        :'vertx' => :'vertx',
        :'number_of_encoder_not_opened_errors' => :'numberOfEncoderNotOpenedErrors',
        :'shutdown_properly' => :'shutdownProperly',
        :'web_rtc_video_receive_stats' => :'webRTCVideoReceiveStats',
        :'web_rtc_audio_receive_stats' => :'webRTCAudioReceiveStats',
        :'web_rtc_video_send_stats' => :'webRTCVideoSendStats',
        :'web_rtc_audio_send_stats' => :'webRTCAudioSendStats',
        :'server_shutting_down' => :'serverShuttingDown',
        :'storage_client' => :'storageClient',
        :'http_client' => :'httpClient',
        :'data_channel_messaging_supported' => :'dataChannelMessagingSupported',
        :'data_channel_enabled' => :'dataChannelEnabled',
        :'number_of_encoders_blocked' => :'numberOfEncodersBlocked',
        :'number_of_publish_timeout_error' => :'numberOfPublishTimeoutError',
        :'stream_publish_security' => :'streamPublishSecurity',
        :'stream_playback_security' => :'streamPlaybackSecurity',
        :'scheduled_job_names' => :'scheduledJobNames',
        :'client_ttl' => :'clientTTL',
        :'ghost_conns_cleanup_period' => :'ghostConnsCleanupPeriod',
        :'name' => :'name',
        :'parent' => :'parent',
        :'context' => :'context',
        :'path' => :'path',
        :'attributes' => :'attributes',
        :'depth' => :'depth',
        :'attribute_names' => :'attributeNames',
        :'clients' => :'clients',
        :'connections' => :'connections',
        :'child_scope_names' => :'childScopeNames'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'scope' => :'IScope',
        :'plugins' => :'Array<PluginDescriptor>',
        :'listeners' => :'Array<IApplication>',
        :'server_settings' => :'ServerSettings',
        :'stream_publish_security_list' => :'Array<IStreamPublishSecurity>',
        :'stream_fetcher_manager' => :'StreamFetcherManager',
        :'mux_adaptors' => :'Array<MuxAdaptor>',
        :'data_store' => :'DataStore',
        :'data_store_factory' => :'DataStoreFactory',
        :'stream_accept_filter' => :'StreamAcceptFilter',
        :'app_settings' => :'AppSettings',
        :'vertx' => :'Vertx',
        :'number_of_encoder_not_opened_errors' => :'Integer',
        :'shutdown_properly' => :'BOOLEAN',
        :'web_rtc_video_receive_stats' => :'WebRTCVideoReceiveStats',
        :'web_rtc_audio_receive_stats' => :'WebRTCAudioReceiveStats',
        :'web_rtc_video_send_stats' => :'WebRTCVideoSendStats',
        :'web_rtc_audio_send_stats' => :'WebRTCAudioSendStats',
        :'server_shutting_down' => :'BOOLEAN',
        :'storage_client' => :'StorageClient',
        :'http_client' => :'CloseableHttpClient',
        :'data_channel_messaging_supported' => :'BOOLEAN',
        :'data_channel_enabled' => :'BOOLEAN',
        :'number_of_encoders_blocked' => :'Integer',
        :'number_of_publish_timeout_error' => :'Integer',
        :'stream_publish_security' => :'Array<IStreamPublishSecurity>',
        :'stream_playback_security' => :'Array<IStreamPlaybackSecurity>',
        :'scheduled_job_names' => :'Array<String>',
        :'client_ttl' => :'Integer',
        :'ghost_conns_cleanup_period' => :'Integer',
        :'name' => :'String',
        :'parent' => :'IScope',
        :'context' => :'IContext',
        :'path' => :'String',
        :'attributes' => :'Hash<String, Object>',
        :'depth' => :'Integer',
        :'attribute_names' => :'Array<String>',
        :'clients' => :'Array<IClient>',
        :'connections' => :'Array<Array<IConnection>>',
        :'child_scope_names' => :'Array<String>'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'scope')
        self.scope = attributes[:'scope']
      end

      if attributes.has_key?(:'plugins')
        if (value = attributes[:'plugins']).is_a?(Array)
          self.plugins = value
        end
      end

      if attributes.has_key?(:'listeners')
        if (value = attributes[:'listeners']).is_a?(Array)
          self.listeners = value
        end
      end

      if attributes.has_key?(:'serverSettings')
        self.server_settings = attributes[:'serverSettings']
      end

      if attributes.has_key?(:'streamPublishSecurityList')
        if (value = attributes[:'streamPublishSecurityList']).is_a?(Array)
          self.stream_publish_security_list = value
        end
      end

      if attributes.has_key?(:'streamFetcherManager')
        self.stream_fetcher_manager = attributes[:'streamFetcherManager']
      end

      if attributes.has_key?(:'muxAdaptors')
        if (value = attributes[:'muxAdaptors']).is_a?(Array)
          self.mux_adaptors = value
        end
      end

      if attributes.has_key?(:'dataStore')
        self.data_store = attributes[:'dataStore']
      end

      if attributes.has_key?(:'dataStoreFactory')
        self.data_store_factory = attributes[:'dataStoreFactory']
      end

      if attributes.has_key?(:'streamAcceptFilter')
        self.stream_accept_filter = attributes[:'streamAcceptFilter']
      end

      if attributes.has_key?(:'appSettings')
        self.app_settings = attributes[:'appSettings']
      end

      if attributes.has_key?(:'vertx')
        self.vertx = attributes[:'vertx']
      end

      if attributes.has_key?(:'numberOfEncoderNotOpenedErrors')
        self.number_of_encoder_not_opened_errors = attributes[:'numberOfEncoderNotOpenedErrors']
      end

      if attributes.has_key?(:'shutdownProperly')
        self.shutdown_properly = attributes[:'shutdownProperly']
      end

      if attributes.has_key?(:'webRTCVideoReceiveStats')
        self.web_rtc_video_receive_stats = attributes[:'webRTCVideoReceiveStats']
      end

      if attributes.has_key?(:'webRTCAudioReceiveStats')
        self.web_rtc_audio_receive_stats = attributes[:'webRTCAudioReceiveStats']
      end

      if attributes.has_key?(:'webRTCVideoSendStats')
        self.web_rtc_video_send_stats = attributes[:'webRTCVideoSendStats']
      end

      if attributes.has_key?(:'webRTCAudioSendStats')
        self.web_rtc_audio_send_stats = attributes[:'webRTCAudioSendStats']
      end

      if attributes.has_key?(:'serverShuttingDown')
        self.server_shutting_down = attributes[:'serverShuttingDown']
      end

      if attributes.has_key?(:'storageClient')
        self.storage_client = attributes[:'storageClient']
      end

      if attributes.has_key?(:'httpClient')
        self.http_client = attributes[:'httpClient']
      end

      if attributes.has_key?(:'dataChannelMessagingSupported')
        self.data_channel_messaging_supported = attributes[:'dataChannelMessagingSupported']
      end

      if attributes.has_key?(:'dataChannelEnabled')
        self.data_channel_enabled = attributes[:'dataChannelEnabled']
      end

      if attributes.has_key?(:'numberOfEncodersBlocked')
        self.number_of_encoders_blocked = attributes[:'numberOfEncodersBlocked']
      end

      if attributes.has_key?(:'numberOfPublishTimeoutError')
        self.number_of_publish_timeout_error = attributes[:'numberOfPublishTimeoutError']
      end

      if attributes.has_key?(:'streamPublishSecurity')
        if (value = attributes[:'streamPublishSecurity']).is_a?(Array)
          self.stream_publish_security = value
        end
      end

      if attributes.has_key?(:'streamPlaybackSecurity')
        if (value = attributes[:'streamPlaybackSecurity']).is_a?(Array)
          self.stream_playback_security = value
        end
      end

      if attributes.has_key?(:'scheduledJobNames')
        if (value = attributes[:'scheduledJobNames']).is_a?(Array)
          self.scheduled_job_names = value
        end
      end

      if attributes.has_key?(:'clientTTL')
        self.client_ttl = attributes[:'clientTTL']
      end

      if attributes.has_key?(:'ghostConnsCleanupPeriod')
        self.ghost_conns_cleanup_period = attributes[:'ghostConnsCleanupPeriod']
      end

      if attributes.has_key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.has_key?(:'parent')
        self.parent = attributes[:'parent']
      end

      if attributes.has_key?(:'context')
        self.context = attributes[:'context']
      end

      if attributes.has_key?(:'path')
        self.path = attributes[:'path']
      end

      if attributes.has_key?(:'attributes')
        if (value = attributes[:'attributes']).is_a?(Hash)
          self.attributes = value
        end
      end

      if attributes.has_key?(:'depth')
        self.depth = attributes[:'depth']
      end

      if attributes.has_key?(:'attributeNames')
        if (value = attributes[:'attributeNames']).is_a?(Array)
          self.attribute_names = value
        end
      end

      if attributes.has_key?(:'clients')
        if (value = attributes[:'clients']).is_a?(Array)
          self.clients = value
        end
      end

      if attributes.has_key?(:'connections')
        if (value = attributes[:'connections']).is_a?(Array)
          self.connections = value
        end
      end

      if attributes.has_key?(:'childScopeNames')
        if (value = attributes[:'childScopeNames']).is_a?(Array)
          self.child_scope_names = value
        end
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          scope == o.scope &&
          plugins == o.plugins &&
          listeners == o.listeners &&
          server_settings == o.server_settings &&
          stream_publish_security_list == o.stream_publish_security_list &&
          stream_fetcher_manager == o.stream_fetcher_manager &&
          mux_adaptors == o.mux_adaptors &&
          data_store == o.data_store &&
          data_store_factory == o.data_store_factory &&
          stream_accept_filter == o.stream_accept_filter &&
          app_settings == o.app_settings &&
          vertx == o.vertx &&
          number_of_encoder_not_opened_errors == o.number_of_encoder_not_opened_errors &&
          shutdown_properly == o.shutdown_properly &&
          web_rtc_video_receive_stats == o.web_rtc_video_receive_stats &&
          web_rtc_audio_receive_stats == o.web_rtc_audio_receive_stats &&
          web_rtc_video_send_stats == o.web_rtc_video_send_stats &&
          web_rtc_audio_send_stats == o.web_rtc_audio_send_stats &&
          server_shutting_down == o.server_shutting_down &&
          storage_client == o.storage_client &&
          http_client == o.http_client &&
          data_channel_messaging_supported == o.data_channel_messaging_supported &&
          data_channel_enabled == o.data_channel_enabled &&
          number_of_encoders_blocked == o.number_of_encoders_blocked &&
          number_of_publish_timeout_error == o.number_of_publish_timeout_error &&
          stream_publish_security == o.stream_publish_security &&
          stream_playback_security == o.stream_playback_security &&
          scheduled_job_names == o.scheduled_job_names &&
          client_ttl == o.client_ttl &&
          ghost_conns_cleanup_period == o.ghost_conns_cleanup_period &&
          name == o.name &&
          parent == o.parent &&
          context == o.context &&
          path == o.path &&
          attributes == o.attributes &&
          depth == o.depth &&
          attribute_names == o.attribute_names &&
          clients == o.clients &&
          connections == o.connections &&
          child_scope_names == o.child_scope_names
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [scope, plugins, listeners, server_settings, stream_publish_security_list, stream_fetcher_manager, mux_adaptors, data_store, data_store_factory, stream_accept_filter, app_settings, vertx, number_of_encoder_not_opened_errors, shutdown_properly, web_rtc_video_receive_stats, web_rtc_audio_receive_stats, web_rtc_video_send_stats, web_rtc_audio_send_stats, server_shutting_down, storage_client, http_client, data_channel_messaging_supported, data_channel_enabled, number_of_encoders_blocked, number_of_publish_timeout_error, stream_publish_security, stream_playback_security, scheduled_job_names, client_ttl, ghost_conns_cleanup_period, name, parent, context, path, attributes, depth, attribute_names, clients, connections, child_scope_names].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = AntmediaClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end
end
